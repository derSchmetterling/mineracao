---
title: "Desafio 2"
subtitle: "Predizendo probabilidade de adquirir aluguel para máquinas"
author: Pedro Vinícius Alves Silva - 10727865
format:
  html:
    embed-resources: true
    fontsize: 15pt
    theme: sandstone
    code-fold: true
    echo: true
    number-sections: false
    code-tools: true
    toc: true
    df-print: paged
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Bibliotecas

```{r bibliotecas, warning=FALSE, message=FALSE}

library(lares)
library(ggplot2)
library(dplyr)
library(readxl)
library(GGally)
library(gamlss)
library(nnet)
library(caret)
```

# Amostragem e divisão treino e teste

Procedimentos de amostragem e divisão de treino e teste estão disponíveis no arquivo .qmd.

```{r}
# data <-  read_excel('ChoiceBehaviour.xlsx')
# head(data)
```

```{r}
#| echo: false
# set.seed(10727865)
# sampled_df <- sample_n(data, 2000)
# write.csv(sampled_df,'baseprincipal.csv', sep = '/t', row.names = F)
# 
# sampled_df <- data.frame(sampled_df)
# 
# sampled_df[c(1,2),]
```

```{r}
#| echo: false
# train_idx <- caret::createDataPartition(sampled_df$Resposta, p =0.7, list = FALSE)
# 
# train_df <- sampled_df[train_idx,]
# test_df <- sampled_df[-train_idx,]
# 
# write.csv(train_df,'basetreino.csv', sep = '/t', row.names = F)
# 
# write.csv(test_df,'baseteste.csv', sep = '/t', row.names = F)
```

# Análise Exploratória

## Descrição do problema

Temos um conjunto de dados referentes ao aluguel de três máquinas por agricultores, as colunas são referentes a:

-   **Regiao:** variável discreta representando local onde moram os agricultores

-   **Prima:** variável discreta representando valor que o agricultor precisa pagar para reparar a máquina

-   **CustoProduto:** variável inteira positiva representando custo estimado do maquinário no momento do aluguel pelo agricultor

-   **Pmaquinabase:** variável contínua positiva representando o preço do aluguel da máquina base para dar cobertura ao assegurado

-   **Pmaquina1:** variável contínua positiva representando o preço do aluguel da máquina 1 ofertado ao agricultor

-   **Pmaquina2:** variável contínua positiva representando o preço do aluguel da máquina 2 ofertado ao agricultor

-   **Pmaquina3:** variável contínua positiva representando o preço do aluguel da máquina 3 ofertado ao agricultor

-   **Cmaquina1:** variável contínua positiva representando o custo do aluguel da máquina 1 ofertado ao agricultor

-   **Cmaquina2:** variável contínua positiva representando o custo do aluguel da máquina 2 ofertado ao agricultor

-   **Cmaquina3:** variável contínua positiva representando o custo do aluguel da máquina 3 ofertado ao agricultor

-   **Resposta:** variável discreta, assume o valor de 0 quando o agricultor não aluga nenhum máquina ou o número relativa a qual máquina ele alugou (1,2, ou 3).

O agricultor conhece apenas o valor de reparo das máquina (Prima) e o preço de aluguel de cada uma (Pmaquina1,Pmaquina2,Pmaquina3), enquanto a companhia tem conhecimento de todas as variáveis. **Assim, queremos construir um modelo que prediza qual máquina determinado agricultor vai alugar, desconsiderando aqueles clientes que não alugaram nenhuma.**

*Como não possuimos referências para saber qual a moeda na qual os preços são definidos, usamos o termo **unidades de moeda (u.m)** durante o trabalho.*

```{r}
complete_data <- read.csv('baseprincipal.csv')
data_train <-  read.csv('basetreino.csv')
data_test <-  read.csv('baseteste.csv')

complete_data <-  complete_data[,-1] %>% 
        mutate_at(vars(CustoProduto), as.integer) %>% 
        mutate_at(vars(Resposta), as.factor) %>% 
        filter(Resposta != '0')


complete_data[,11] <- droplevels(complete_data[,11])


data_train <- data_train[,-1] %>% 
        mutate_at(vars(CustoProduto), as.integer) %>% 
        mutate_at(vars(Resposta), as.factor) %>% 
        filter(Resposta != '0')

data_train[,11] <- droplevels(data_train[,11])


data_test <- data_test[,-1] %>% 
        mutate_at(vars(CustoProduto), as.integer) %>% 
        mutate_at(vars(Resposta), as.factor) %>% 
        filter(Resposta != '0')

data_test[,11] <- droplevels(data_test[,11])


head(data_train)
data_train
```

Inicialmente vemos que não há valores faltantes nem no conjunto de treino nem no conjunto de teste

```{r, message=FALSE, warning=FALSE}
library(VIM)
aggr(data_test, col = c('green','red'), numbers = TRUE, sortVars = TRUE, 
     labels = names(data_train), cex.axis = .5, gap = 2, 
     ylab = c("Proportion in variable","Proportion in dataset"))
```

## Custos e Preços

Analisando rapidamente a média e a mediana dos preços, notamos que preços são próximos entre todas as máquinas, temos aproximadamente uma diferença de 50 a 100 u.m entre as possíveis escolhas. Assim, prosseguindo a análise, aplicamos o teste de Kruskal-Wallis para verificar se as distribuições de preço provém da mesma distribuição.

```{r, warning=FALSE}
summary(data_train[, c('Pmaquina1', 'Pmaquina2', 'Pmaquina3' )])
```

Assumindo um nível de significância de 5%, não rejeitamos a hipótese nula de que as distribuições são semelhantes.

```{r, warning=FALSE}
# ks.test(data_train$Pmaquina1, data_train$Pmaquina2 )
# ks.test(data_train$Pmaquina1, data_train$Pmaquina3 )
# ks.test(data_train$Pmaquina2, data_train$Pmaquina3 )

c1 <- unlist(data_train['Pmaquina1'], use.names = FALSE)
c2 <- unlist(data_train['Pmaquina2'], use.names = FALSE)
c3 <- unlist(data_train['Pmaquina3'], use.names = FALSE)


data <- c(c1,c2,c3)
factors <- c(rep('1', 144), rep('2', 144),rep('3', 144))

kruskal.test(data, factors)
```

Analogamente, os custos são em média semelhantes entre as máquinas.

```{r}
summary(data_train[, c('Cmaquina1', 'Cmaquina2', 'Cmaquina3' )])
```

```{r, warning=FALSE}
# ks.test(data_train$Cmaquina1, data_train$Cmaquina2 )
# ks.test(data_train$Cmaquina1, data_train$Cmaquina3 )
# ks.test(data_train$Cmaquina2, data_train$Cmaquina3 )


c1 <- unlist(data_train['Cmaquina1'], use.names = FALSE)
c2 <- unlist(data_train['Cmaquina2'], use.names = FALSE)
c3 <- unlist(data_train['Cmaquina3'], use.names = FALSE)


data <- c(c1,c2,c3)
factors <- c(rep('1', 144), rep('2', 144),rep('3', 144))

kruskal.test(data, factors)
```

Assim, uma rápida análise preliminar indica que, em média, o preço e o custos das máquinas não parece diferir. Logo, pode ser que este não seja um fator fundamental para a escolha dos clientes na amostra obtida.

## Seleção de Features

### Correlações

Analisando a correlação linear entre as variáveis numéricas, notamos que as variáveis relativas ao custo das máquinas e o preço do aluguel estão fortemente relacionadas, como é de se esperar. Porém, é importante ressaltar como o custo de uma máquina está intimamente correlacionado com o preço de aluguel de outra ([*Pmaquina3*]{.underline} e *Cmaquina1* tem 0.82, por exemplo).

As variáveis *CustoProduto* e *Prima* foram as que apresentaram menor correlação com as outras, com coeficientes de menores ou iguais a 0.6, porém todas as correlações são estatisticamente diferentes de 0 ao nível de 5% de significância.

```{r}
#numeric <- c("AGE", "SENIORITY")
df_pearson<- data_train[, -c(1,11)]


correl<- cor(df_pearson, method = 'pearson')

testRes = corrplot::cor.mtest(df_pearson, conf.level = 0.95, method = 'pearson')

corrplot::corrplot(correl, p.mat = testRes$p, addCoef.col ='black',method = 'square', order = 'FPC', type = 'lower', insig = 'blank', number.cex=0.6)
```

Usando o coeficiente de Kendall e adicionando as covariáveis categóricas, nota-se como a *Regiao* tem correlação estatisticamente igual a zero com todas as outras covariáveis. É interessante ver também que *Cmaquina3 e Pmaquina1* não apresentam correlação com a variável Resposta e, de modo, geral, todas as covariáveis tem correlação monotônica fraca com a variável dependente.

```{r, warning=FALSE}

df_spearman <- data_train %>% 
  mutate_at(vars(Resposta), as.integer)

correl<- cor(df_spearman, method = 'kendall')

testRes = corrplot::cor.mtest(df_spearman, conf.level = 0.95, method = 'spearman')

corrplot::corrplot(correl, p.mat = testRes$p, addCoef.col ='black',method = 'square', order = 'FPC', type = 'lower', insig = 'blank', number.cex=0.6)
```

### ANOVA F-Score

Em seguida, utilizamos F-Score para escolher um conjunto de três variáveis para representar o conjunto de dados completo.

```{python}
import pandas as pd
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import f_classif


df = pd.read_csv('basetreino.csv')
df = df[df['Resposta'] != 0]

df['CustoProduto'] = df['CustoProduto'].astype(int)
df = df.drop('Id', axis = 1)
df['CustoProduto'] = df['CustoProduto'].astype(str).apply(lambda x: x[:-2])


```

```{python}

x = df.iloc[:,1:10]
y = df.iloc[:,10]


fs = SelectKBest(score_func=f_classif, k=3)
# aplica o método
X_selected = fs.fit_transform(x, y)
print('Features selecionadas: ')
fs.get_feature_names_out()
```

```{python}
col_names = ['Prima', 'Pmaquina2', 'Pmaquina3']
df_reduced = pd.DataFrame(X_selected, columns = col_names )
```

Vimos anteriormente também que *Pmaquina1,* Pmaquina*2*, *Pmaquina3* tem um correlação linear alta de acima de 0.9, então usaremos arbitrariamente apenas *Pmaquina1*, terminando com o seguinte conjunto de dados:

```{r}
# df_reg <- data_train %>% 
#   dplyr::select(c('Resposta', 'Pmaquina1', 'Prima'))
# 
# df_test <- data_test %>% 
#   dplyr::select(c('Resposta', 'Pmaquina1', 'Prima'))
# 
# 
# head(df_reg)

```

### Clusterização

Para termos uma ideia do perfil dos clientes, vamos aplicar um procedimento de agrupamento. Para isso, escalamos os dados númericos para que diferentes dimensões não afetem a análise de processo.

```{python}
#| warning: false

import pandas as pd
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import f_classif
from sklearn.preprocessing import StandardScaler

df_scaled = df.copy()
df_scaled.iloc[:,0:10] = StandardScaler().fit_transform(df_scaled.iloc[:,0:10])
df_scaled.head()
```

Aplicamos o agrupamento hierárquico usando o método 'ward'.

```{python}
from sklearn.cluster import AgglomerativeClustering

#complete


cluster = AgglomerativeClustering(n_clusters = 3,
distance_threshold=None,
compute_distances = True,
linkage='ward')
model = cluster.fit(df_scaled)

```

```{python}

df_cluster = df.copy()
df_cluster['HCluster'] = model.labels_.astype(str)
df_cluster.sort_values(by = 'HCluster', inplace=True)
df_cluster['CustoProduto'] = df_cluster['CustoProduto'].astype(int)


```

```{python}
import seaborn as sns
import matplotlib.pyplot as plt
sns.set_palette(sns.color_palette("tab10",4))
fig, ax = plt.subplots(1,2, figsize=(12,9))
fig.tight_layout(pad=6.0)

p1 = sns.scatterplot(data = df_cluster,y = 'Prima', x = 'Pmaquina1',
hue = 'HCluster',
ax = ax[0])
p1.set(title = 'Prima vs Pmaquina3',ylabel = 'Custo de Matéria Prima',xlabel = 'Preço da Máquina 1')

# p2 = sns.scatterplot(data = df_cluster,x = 'Prima', y = 'Pmaquina2',
# hue = 'HCluster',
# ax = ax[1])
# p2.set(title = 'Prima por Pmaquina3',xlabel = 'Custo de Matéria Prima',ylabel = 'Preço da Máquina 3')



p2 = sns.histplot(data = df_cluster,
x = 'Resposta',
hue = 'HCluster',
discrete = True,
multiple = 'stack',
ax = ax[1])
p2.set(title = 'Clusterização Hierárquica',
xlabel = 'Máquina Alugada',
ylabel = 'Frequência')



plt.show()
```

```{python}

from sklearn.cluster import KMeans
from sklearn.cluster import MiniBatchKMeans

cluster = KMeans(random_state = 10727865, n_clusters = 3, init = 'k-means++')
model_k = cluster.fit(df_scaled)


df_cluster['KMeans'] = model_k.labels_.astype(str)
df_cluster.sort_values(by = 'KMeans', inplace=True)
```

Ao plotar o custo de matéria prima e o preço da máquina 3 e analisando os agrupamentos gerados, conseguimos encontrar 3 grupos de clientes. Quando o preço da máquina 3 é alto, os clientes do grupo 1 parecem ter uma tendência maior a alugar a máquina 1. Analogamente, clientes do grupo 0, ao serem apresentados a um preço baixo da máquina 3, preferem alugar a máquina 2. Já os indivíduos do grupo 2, parecem ter uma preferência pelas máquinas 1 e 2, em detrimento da 3.

## Distribuição da Variável Resposta

Analisando a variável relativa ao aluguel de máquinas pelos agricultores, vemos que a grande maioria deles não alugou nenhuma.

```{r}
hist_resp <- ggplot(data_train %>% count(Resposta) %>%    
         mutate(pct=n/sum(n)),
       aes(as.factor(Resposta), n, fill = Resposta)) +
  geom_bar(stat="identity") +
  scale_fill_manual(values = c("#0072B2", "#D55E00", "#009E73"))+
  #geom_text(aes(label=paste0(sprintf("%1.1f", pct*100),"%")), position=position_stack(vjust=0.5)) +
  labs(x = 'Aluguel de Máquinas', y = 'Frequência Absoluta', title = "Distribuição de Resposta")

hist_resp
```

No total 144 indivíduos alugaram alguma das máquinas, sendo a máquina 2 a mais frequente.

```{r}
#n_diff_zero <- nrow(filter(data_train, Resposta != 0))
n_a1 <- nrow(filter(data_train, Resposta == 1))
n_a2 <- nrow(filter(data_train, Resposta == 2))
n_a3 <- nrow(filter(data_train, Resposta == 3))


train <- c(nrow(data_train),n_a1, n_a2, n_a3)



rent <-  data.frame(Alugadas = c(nrow(data_train),n_a1, n_a2, n_a3),
                    row.names = c('Total Alugadas','Alugou 1','Alugou 2', 'Alugou 3' ))

rent
```

### Resposta vs Custo

```{r}

hist_resp <- ggplot(data_train,
       aes(Prima, Pmaquina1, colour = as.factor(Resposta) )) +
  geom_point(stat="identity") +
  #geom_text(aes(label=paste0(sprintf("%1.1f", pct*100),"%")), position=position_stack(vjust=0.5)) +
  scale_colour_manual(guide_legend(title="Máquina Alugada"), values = c("#0072B2", "#D55E00", "#009E73")) + 
  #scale_x_discrete(guide = guide_axis(n.dodge=3))+
  labs(y = 'Preço da Máquina 1', x = 'Custo de Matéria Prima', title = "Distribuição de Resposta")

hist_resp

# hist_resp <- ggplot(data_train,
#        aes(Prima, Pmaquina1, colour = as.factor(Resposta) )) +
#   geom_point(stat="identity") +
#   #geom_text(aes(label=paste0(sprintf("%1.1f", pct*100),"%")), position=position_stack(vjust=0.5)) +
#   scale_fill_manual(guide_legend(title="Aluguel de Máquinas"), values = c("#D95F02", "#1B9E77", "blue")) + 
#   #scale_x_discrete(guide = guide_axis(n.dodge=3))+
#   labs(x = 'Aluguel de Máquinas', y = 'Frequência Absoluta', title = "Distribuição de Resposta")


hist_resp


```

```{r}
hist_resp <- ggplot(data_train,
       aes(CustoProduto, Prima, colour = as.factor(Resposta) )) +
  geom_point(stat="identity") +
  #geom_text(aes(label=paste0(sprintf("%1.1f", pct*100),"%")), position=position_stack(vjust=0.5)) +
  scale_colour_manual(guide_legend(title="Máquina Alugada"), values = c("#0072B2", "#D55E00", "#009E73")) + 
  #scale_x_discrete(guide = guide_axis(n.dodge=3))+
  labs(y = 'Preço da Máquina 1', x = 'Custo de Matéria Prima', title = "Distribuição de Resposta")

hist_resp
```

```{r}
knitr::knit_exit()
```

## 

## Ajuste de Modelos

### Modelo Multinomial

Usando as variáveis usadas para a construção das três componentes principais e excluindo aqueles com alta correlação linear entre si, terminamos com *Prima* e *Pmaquina3*

```{r}

df_reg <- data_train

df_reg$Resposta2 <- relevel(df_reg$Resposta, ref = "1")
complete_data$Resposta2 <- relevel(complete_data$Resposta, ref = "1")


m1 <- multinom(Resposta2 ~ Prima + CustoProduto + Regiao +  + Pmaquina1 + Pmaquina2 , data = df_reg)

summary(m1)

#unique(predict(m1, newdata = reduced_data1, type = 'class'))


```

```{r}
z <- summary(m1)$coefficients/summary(m1)$standard.errors
z

p <- (1 - pnorm(abs(z), 0, 1)) * 2
p
```

```{r}
preds_class <- predict(m1,type = 'class', newdata = data_test)
preds_score <- predict(m1,type = 'probs', newdata = data_test)

postResample(data_test$Resposta, preds_class)
```

```{r, warning=FALSE}


totalAccuracy <- c()
cv <- 10
cvDivider <- floor(nrow(complete_data) / (cv+1))

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- complete_data[dataTestIndex,]
  # everything else to train
  dataTrain <- complete_data[-dataTestIndex,]
 
  cylModel <-  multinom(Resposta2 ~ Prima + Pmaquina1 + Regiao + CustoProduto, data = dataTrain)
 
  pred <- predict(cylModel, newdata=dataTest, type="class")
 
  #  classification error
  cv_ac <- postResample(dataTest$Resposta2, pred)[[1]]
  print(paste('Current Accuracy:',cv_ac,'for CV:',cv))
  totalAccuracy <- c(totalAccuracy, cv_ac)
}
```

```{r}
 mean(totalAccuracy)  
```

### Random Forest

```{r, warning=FALSE}
library(randomForest)

df_reg[,12] <- droplevels(df_reg[,12])

y <-  df_reg[,12]
x <- df_reg %>% 
  dplyr::select(c('Pmaquina1', 'Prima'))

t <- tuneRF(x, y,
       stepFactor = 0.5,
       plot = TRUE,
       ntreeTry = 150,
       trace = TRUE,
       improve = 0.05)

```

```{r}

repeat_cv <- trainControl(method="repeatedcv", number=10, repeats=3, search="random")
set.seed(10727865)


forest <- train(
        
        # Formula. We are using all variables to predict Species
        Resposta~., 
        
        # Source of data; remove the Species variable
        data=complete_data, 
        
        # `rf` method for random forest
        method='rf', 
        
        # Add repeated cross validation as trControl
        trControl=repeat_cv,
        
        # Accuracy to measure the performance of the model
        metric='Accuracy')

## Print out the details about the model
forest$finalModel

names(forest)
forest$coefnames

```

```{r}
## Get variable importance, and turn into a data frame
var_imp <- varImp(forest, scale=FALSE)$importance
var_imp <- data.frame(variables=row.names(var_imp), importance=var_imp$Overall)

## Create a plot of variable importance
var_imp %>%
        
        ## Sort the data by importance
        arrange(importance) %>%
        
        ## Create a ggplot object for aesthetic
        ggplot(aes(x=reorder(variables, importance), y=importance)) + 
        
        ## Plot the bar graph
        geom_bar(stat='identity') + 
        
        ## Flip the graph to make a horizontal bar plot
        coord_flip() + 
        
        ## Add x-axis label
        xlab('Variables') +
        
        ## Add a title
        labs(title='Random forest variable importance') + 
        
        ## Some layout for the plot
        theme_minimal() + 
        theme(axis.text = element_text(size = 10), 
              axis.title = element_text(size = 15), 
              plot.title = element_text(size = 20), 
              )
```

```{r}
preds <- predict(rf, newdata = data_test, type = 'response')

postResample(data_test$Resposta, preds)
```

```{r}
y_hats <- predict(
        
        ## Random forest object
        object=forest, 
        
        ## Data to use for predictions; remove the Species
        newdata=data_test[, -11])

## Print the accuracy
accuracy <- mean(y_hats == data_test$Resposta)*100
cat('Accuracy on testing data: ', round(accuracy, 2), '%',  sep='')
```

## Bibliografia

https://amunategui.github.io/multinomial-neuralnetworks-walkthrough/index.html

https://stats.oarc.ucla.edu/r/dae/multinomial-logistic-regression/
